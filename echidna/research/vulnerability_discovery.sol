// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title Novel Vulnerability Discovery Lab
 * @dev Framework for discovering new vulnerability classes through systematic fuzzing
 */

// =============================================================================
// 1. STATE CORRUPTION VULNERABILITIES
// =============================================================================

contract StateCorruptionLab {
    mapping(address => uint256) public balances;
    mapping(address => mapping(address => uint256)) public allowances;
    uint256 public totalSupply;
    uint256 private lockedAmount;
    bool private locked;
    uint256 public lastOperation;
    
    // Novel pattern: State inconsistency through complex operations
    function complexTransfer(address from, address to, uint256 amount, bool useAllowance) public {
        if (useAllowance) {
            require(allowances[from][msg.sender] >= amount, "Insufficient allowance");
            allowances[from][msg.sender] -= amount;
        } else {
            require(msg.sender == from, "Unauthorized");
        }
        
        require(balances[from] >= amount, "Insufficient balance");
        
        // Potential vulnerability: State update ordering
        balances[from] -= amount;
        lastOperation = block.timestamp;
        balances[to] += amount;
        
        // Complex condition that might create edge cases
        if (amount > totalSupply / 100 && !locked) {
            lockedAmount += amount / 10;
        }
    }
    
    // Echidna properties to discover state corruption
    function echidna_total_balance_conservation() public view returns (bool) {
        // This should always hold, failures indicate novel state corruption
        uint256 sumBalances = 0;
        // Note: In real implementation, we'd need to track all addresses
        return true; // Simplified for research framework
    }
    
    function echidna_allowance_consistency() public view returns (bool) {
        // Check for negative allowances or overflow conditions
        return allowances[msg.sender][address(this)] <= type(uint256).max;
    }
    
    function echidna_locked_amount_bounds() public view returns (bool) {
        return lockedAmount <= totalSupply;
    }
}

// =============================================================================
// 2. TEMPORAL LOGIC VULNERABILITIES
// =============================================================================

contract TemporalLogicLab {
    struct TimedAction {
        uint256 timestamp;
        address user;
        uint256 amount;
        bool executed;
    }
    
    mapping(uint256 => TimedAction) public timedActions;
    mapping(address => uint256) public userLastAction;
    uint256 public nextActionId;
    uint256 public constant COOLDOWN = 1 hours;
    uint256 public constant EXECUTION_WINDOW = 30 minutes;
    
    // Novel pattern: Complex temporal dependencies
    function scheduleAction(uint256 amount, uint256 delay) public {
        require(delay >= COOLDOWN, "Delay too short");
        require(block.timestamp >= userLastAction[msg.sender] + COOLDOWN, "User cooldown");
        
        uint256 actionId = nextActionId++;
        timedActions[actionId] = TimedAction({
            timestamp: block.timestamp + delay,
            user: msg.sender,
            amount: amount,
            executed: false
        });
        
        userLastAction[msg.sender] = block.timestamp;
    }
    
    function executeAction(uint256 actionId) public {
        TimedAction storage action = timedActions[actionId];
        require(action.user == msg.sender, "Not your action");
        require(!action.executed, "Already executed");
        require(block.timestamp >= action.timestamp, "Too early");
        require(block.timestamp <= action.timestamp + EXECUTION_WINDOW, "Too late");
        
        action.executed = true;
        // Process action...
    }
    
    // Properties to discover temporal vulnerabilities
    function echidna_no_time_travel() public view returns (bool) {
        return block.timestamp >= userLastAction[msg.sender];
    }
    
    function echidna_execution_window_respected() public view returns (bool) {
        // Check that no executed action violates timing constraints
        return true; // Simplified - would check all actions in real implementation
    }
    
    function echidna_cooldown_enforced() public view returns (bool) {
        // Verify cooldown periods are properly enforced
        return userLastAction[msg.sender] <= block.timestamp;
    }
}

// =============================================================================
// 3. CROSS-FUNCTIONAL INTERACTION VULNERABILITIES
// =============================================================================

contract CrossFunctionalLab {
    enum Mode { NORMAL, EMERGENCY, MAINTENANCE }
    Mode public currentMode;
    
    mapping(address => uint256) public stakes;
    mapping(address => uint256) public rewards;
    mapping(address => bool) public isValidator;
    
    uint256 public totalStaked;
    uint256 public rewardPool;
    address public admin;
    
    modifier onlyMode(Mode requiredMode) {
        require(currentMode == requiredMode, "Wrong mode");
        _;
    }
    
    modifier onlyAdmin() {
        require(msg.sender == admin, "Not admin");
        _;
    }
    
    constructor() {
        admin = msg.sender;
        currentMode = Mode.NORMAL;
    }
    
    // Function interactions that might create vulnerabilities
    function stake(uint256 amount) public onlyMode(Mode.NORMAL) {
        stakes[msg.sender] += amount;
        totalStaked += amount;
        
        if (stakes[msg.sender] >= 1000 ether) {
            isValidator[msg.sender] = true;
        }
    }
    
    function unstake(uint256 amount) public {
        require(stakes[msg.sender] >= amount, "Insufficient stake");
        
        stakes[msg.sender] -= amount;
        totalStaked -= amount;
        
        if (stakes[msg.sender] < 1000 ether) {
            isValidator[msg.sender] = false;
        }
    }
    
    function distributeRewards() public onlyMode(Mode.NORMAL) {
        require(isValidator[msg.sender], "Not validator");
        
        uint256 reward = rewardPool / getValidatorCount();
        rewards[msg.sender] += reward;
        rewardPool -= reward;
    }
    
    function switchMode(Mode newMode) public onlyAdmin {
        currentMode = newMode;
        
        // Mode-specific logic that might create vulnerabilities
        if (newMode == Mode.EMERGENCY) {
            // Emergency logic
            rewardPool = 0; // Potential vulnerability: Reward loss
        }
    }
    
    function getValidatorCount() public view returns (uint256) {
        // Simplified - would count all validators in real implementation
        return isValidator[msg.sender] ? 1 : 0;
    }
    
    // Properties to discover cross-functional vulnerabilities
    function echidna_stake_consistency() public view returns (bool) {
        return stakes[msg.sender] <= totalStaked;
    }
    
    function echidna_validator_status_consistency() public view returns (bool) {
        if (stakes[msg.sender] >= 1000 ether) {
            return isValidator[msg.sender];
        }
        return true;
    }
    
    function echidna_mode_safety() public view returns (bool) {
        // Emergency mode shouldn't break core invariants
        return totalStaked >= stakes[msg.sender];
    }
    
    function echidna_reward_conservation() public view returns (bool) {
        // Rewards should not exceed pool unless in specific conditions
        return rewards[msg.sender] <= 1000000 ether; // Reasonable upper bound
    }
}

// =============================================================================
// 4. ECONOMIC LOGIC VULNERABILITIES
// =============================================================================

contract EconomicLogicLab {
    struct Pool {
        uint256 tokenA;
        uint256 tokenB;
        uint256 totalShares;
        uint256 fee; // Basis points (e.g., 30 = 0.3%)
    }
    
    Pool public pool;
    mapping(address => uint256) public shares;
    mapping(address => uint256) public lastPriceSnapshot;
    
    uint256 public constant MIN_LIQUIDITY = 1000;
    uint256 public priceOracle;
    bool public emergencyStop;
    
    // Complex economic interactions
    function addLiquidity(uint256 amountA, uint256 amountB) public {
        require(!emergencyStop, "Emergency stop active");
        require(amountA > 0 && amountB > 0, "Invalid amounts");
        
        uint256 sharesMinted;
        
        if (pool.totalShares == 0) {
            sharesMinted = sqrt(amountA * amountB);
            require(sharesMinted >= MIN_LIQUIDITY, "Insufficient liquidity");
        } else {
            uint256 sharesA = (amountA * pool.totalShares) / pool.tokenA;
            uint256 sharesB = (amountB * pool.totalShares) / pool.tokenB;
            sharesMinted = sharesA < sharesB ? sharesA : sharesB;
        }
        
        pool.tokenA += amountA;
        pool.tokenB += amountB;
        pool.totalShares += sharesMinted;
        shares[msg.sender] += sharesMinted;
        
        lastPriceSnapshot[msg.sender] = getCurrentPrice();
    }
    
    function swap(uint256 amountIn, bool aToB) public {
        require(!emergencyStop, "Emergency stop active");
        require(amountIn > 0, "Invalid amount");
        
        uint256 amountOut;
        uint256 feeAmount = (amountIn * pool.fee) / 10000;
        uint256 amountInAfterFee = amountIn - feeAmount;
        
        if (aToB) {
            amountOut = (pool.tokenB * amountInAfterFee) / (pool.tokenA + amountInAfterFee);
            require(amountOut < pool.tokenB, "Insufficient liquidity");
            
            pool.tokenA += amountIn;
            pool.tokenB -= amountOut;
        } else {
            amountOut = (pool.tokenA * amountInAfterFee) / (pool.tokenB + amountInAfterFee);
            require(amountOut < pool.tokenA, "Insufficient liquidity");
            
            pool.tokenB += amountIn;
            pool.tokenA -= amountOut;
        }
        
        // Price manipulation check (potential vulnerability area)
        uint256 newPrice = getCurrentPrice();
        uint256 priceChange = newPrice > lastPriceSnapshot[msg.sender] ? 
            newPrice - lastPriceSnapshot[msg.sender] : 
            lastPriceSnapshot[msg.sender] - newPrice;
            
        require(priceChange <= lastPriceSnapshot[msg.sender] / 10, "Price manipulation detected");
        lastPriceSnapshot[msg.sender] = newPrice;
    }
    
    function getCurrentPrice() public view returns (uint256) {
        if (pool.tokenB == 0) return 0;
        return (pool.tokenA * 1e18) / pool.tokenB;
    }
    
    function sqrt(uint256 x) internal pure returns (uint256) {
        // Simplified square root implementation
        if (x == 0) return 0;
        uint256 z = (x + 1) / 2;
        uint256 y = x;
        while (z < y) {
            y = z;
            z = (x / z + z) / 2;
        }
        return y;
    }
    
    // Properties to discover economic vulnerabilities
    function echidna_constant_product() public view returns (bool) {
        // K = x * y should generally increase or stay constant (due to fees)
        return pool.tokenA * pool.tokenB >= MIN_LIQUIDITY * MIN_LIQUIDITY;
    }
    
    function echidna_no_arbitrary_minting() public view returns (bool) {
        // Shares should correspond to actual deposits
        return shares[msg.sender] <= pool.totalShares;
    }
    
    function echidna_price_bounds() public view returns (bool) {
        uint256 price = getCurrentPrice();
        // Price should be within reasonable bounds
        return price <= 1000000 * 1e18; // Prevent extreme prices
    }
    
    function echidna_liquidity_preservation() public view returns (bool) {
        // Pool should maintain minimum liquidity
        return pool.tokenA > 0 && pool.tokenB > 0;
    }
}

// =============================================================================
// 5. METADATA MANIPULATION VULNERABILITIES
// =============================================================================

contract MetadataLab {
    struct Token {
        string name;
        string symbol;
        uint8 decimals;
        uint256 totalSupply;
        bool frozen;
        address controller;
    }
    
    mapping(uint256 => Token) public tokens;
    mapping(uint256 => mapping(address => uint256)) public balances;
    uint256 public nextTokenId;
    
    // Functions that manipulate metadata
    function createToken(
        string memory name,
        string memory symbol,
        uint8 decimals,
        uint256 totalSupply
    ) public returns (uint256) {
        uint256 tokenId = nextTokenId++;
        
        tokens[tokenId] = Token({
            name: name,
            symbol: symbol,
            decimals: decimals,
            totalSupply: totalSupply,
            frozen: false,
            controller: msg.sender
        });
        
        balances[tokenId][msg.sender] = totalSupply;
        return tokenId;
    }
    
    function updateMetadata(
        uint256 tokenId,
        string memory newName,
        string memory newSymbol
    ) public {
        require(tokens[tokenId].controller == msg.sender, "Not controller");
        require(!tokens[tokenId].frozen, "Token frozen");
        
        tokens[tokenId].name = newName;
        tokens[tokenId].symbol = newSymbol;
    }
    
    function transfer(uint256 tokenId, address to, uint256 amount) public {
        require(!tokens[tokenId].frozen, "Token frozen");
        require(balances[tokenId][msg.sender] >= amount, "Insufficient balance");
        
        balances[tokenId][msg.sender] -= amount;
        balances[tokenId][to] += amount;
    }
    
    // Properties to discover metadata vulnerabilities
    function echidna_metadata_consistency() public view returns (bool) {
        // Token metadata should remain consistent with economic properties
        return bytes(tokens[0].name).length <= 50; // Reasonable name length
    }
    
    function echidna_controller_privileges() public view returns (bool) {
        // Controller shouldn't have unlimited power
        return !tokens[0].frozen || tokens[0].controller != address(0);
    }
    
    function echidna_balance_metadata_sync() public view returns (bool) {
        // Balances should respect token properties
        return balances[0][msg.sender] <= tokens[0].totalSupply;
    }
}
